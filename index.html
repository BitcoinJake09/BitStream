<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="BitStreams - A peer-to-peer livestreaming platform using WebRTC for secure, decentralized streaming.">
  <meta name="keywords" content="P2P, livestreaming, WebRTC, decentralized, streaming, BitStreams">
  <meta name="author" content="BitcoinJake09">
  <title>BitStreams - P2P Livestreaming</title>
  <style>
    :root {
      --background-light: #f0f0f0;
      --container-bg-light: white;
      --text-color-light: #333;
      --button-bg-light: #007bff;
      --button-hover-light: #0056b3;
      --instructions-bg-light: #e9ecef;
      --comments-bg-light: #fafafa;
      --stream-list-bg-light: #eee;
      --stream-list-hover-light: #ddd;
      --input-bg-light: white;
      --input-text-light: #333;
      --input-border-light: #ccc;
      --shadow-light: rgba(0,0,0,0.1);
      --overlay-bg-light: rgba(0,0,0,0.5);

      --background-dark: #1a1a1a;
      --container-bg-dark: #2a2a2a;
      --text-color-dark: #e0e0e0;
      --button-bg-dark: #1e90ff;
      --button-hover-dark: #1c7cd6;
      --instructions-bg-dark: #333;
      --comments-bg-dark: #222;
      --stream-list-bg-dark: #444;
      --stream-list-hover-dark: #555;
      --input-bg-dark: #333;
      --input-text-dark: #e0e0e0;
      --input-border-dark: #555;
      --shadow-dark: rgba(0,0,0,0.5);
      --overlay-bg-dark: rgba(0,0,0,0.7);

      --background: var(--background-dark);
      --container-bg: var(--container-bg-dark);
      --text-color: var(--text-color-dark);
      --button-bg: var(--button-bg-dark);
      --button-hover: var(--button-hover-dark);
      --instructions-bg: var(--instructions-bg-dark);
      --comments-bg: var(--comments-bg-dark);
      --stream-list-bg: var(--stream-list-bg-dark);
      --stream-list-hover: var(--stream-list-hover-dark);
      --input-bg: var(--input-bg-dark);
      --input-text: var(--input-text-dark);
      --input-border: var(--input-border-dark);
      --shadow: var(--shadow-dark);
      --overlay-bg: var(--overlay-bg-dark);
    }

    :root.light-mode {
      --background: var(--background-light);
      --container-bg: var(--container-bg-light);
      --text-color: var(--text-color-light);
      --button-bg: var(--button-bg-light);
      --button-hover: var(--button-hover-light);
      --instructions-bg: var(--instructions-bg-light);
      --comments-bg: var(--comments-bg-light);
      --stream-list-bg: var(--stream-list-bg-light);
      --stream-list-hover: var(--stream-list-hover-light);
      --input-bg: var(--input-bg-light);
      --input-text: var(--input-text-light);
      --input-border: var(--input-border-light);
      --shadow: var(--shadow-light);
      --overlay-bg: var(--overlay-bg-light);
    }

    :root.dark-mode {
      --background: var(--background-dark);
      --container-bg: var(--container-bg-dark);
      --text-color: var(--text-color-dark);
      --button-bg: var(--button-bg-dark);
      --button-hover: var(--button-hover-dark);
      --instructions-bg: var(--instructions-bg-dark);
      --comments-bg: var(--comments-bg-dark);
      --stream-list-bg: var(--stream-list-bg-dark);
      --stream-list-hover: var(--stream-list-hover-dark);
      --input-bg: var(--input-bg-dark);
      --input-text: var(--input-text-dark);
      --input-border: var(--input-border-dark);
      --shadow: var(--shadow-dark);
      --overlay-bg: var(--overlay-bg-dark);
    }

    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background: var(--background);
      color: var(--text-color);
      transition: all 0.3s ease;
    }

    #container {
      max-width: 800px;
      margin: 0 auto;
      background: var(--container-bg);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 10px var(--shadow);
    }

    video {
      width: 100%;
      max-width: 400px;
      background: black;
      border-radius: 4px;
      margin: 10px 0;
      cursor: pointer;
    }

    #localVideo {
      display: none;
    }

    #remoteVideo {
      display: none;
      width: 100%;
      max-width: 400px;
      background: black;
      border-radius: 4px;
      margin: 10px 0;
    }

    #streamList {
      margin: 20px 0;
      padding: 0;
      list-style: none;
    }

    #streamList li {
      padding: 10px;
      background: var(--stream-list-bg);
      margin: 5px 0;
      border-radius: 4px;
      cursor: pointer;
    }

    #streamList li:hover {
      background: var(--stream-list-hover);
    }

    #comments {
      height: 150px;
      overflow-y: auto;
      border: 1px solid var(--input-border);
      padding: 10px;
      margin: 10px 0;
      background: var(--comments-bg);
      border-radius: 4px;
      color: var(--text-color);
    }

    textarea, input[type="text"], select, input[type="color"], input[type="range"] {
      width: 100%;
      padding: 8px;
      margin: 5px 0;
      border: 1px solid var(--input-border);
      border-radius: 4px;
      box-sizing: border-box;
      background: var(--input-bg);
      color: var(--input-text);
    }

    button {
      padding: 8px 16px;
      background: var(--button-bg);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin: 5px;
    }

    button:hover {
      background: var(--button-hover);
    }

    #instructions {
      margin: 10px 0;
      padding: 10px;
      background: var(--instructions-bg);
      border-radius: 4px;
      display: none;
    }

    #toggleInstructionsBtn {
      margin: 10px 0;
      background: #6c757d;
    }

    #toggleInstructionsBtn:hover {
      background: #5a6268;
    }

    #signalingPopup {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--container-bg);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 10px var(--shadow);
      z-index: 1000;
      width: 80%;
      max-width: 600px;
      color: var(--text-color);
    }

    #signalingOverlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--overlay-bg);
      z-index: 999;
    }

    #settingsPopup {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--container-bg);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 10px var(--shadow);
      z-index: 1000;
      color: var(--text-color);
    }

    #settingsOverlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--overlay-bg);
      z-index: 999;
    }

    #settingsPopup select {
      margin: 5px 0;
      background: var(--input-bg);
      color: var(--input-text);
      border: 1px solid var(--input-border);
    }

    #privacyPopup {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--container-bg);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 10px var(--shadow);
      z-index: 1001;
      width: 80%;
      max-width: 500px;
      color: var(--text-color);
      text-align: center;
    }

    #privacyOverlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--overlay-bg);
      z-index: 1000;
    }

    #volumeControl {
      display: none;
      max-width: 400px;
    }

    .button-group {
      margin: 10px 0;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .section {
      margin-bottom: 20px;
    }

    #streamTitleSection {
      display: none;
      margin: 10px 0;
    }

    #streamTitleDisplay {
      margin: 10px 0;
      font-size: 1.2em;
      font-weight: bold;
    }

    #peersConnected {
      margin: 10px 0;
      font-weight: bold;
    }

    .video-comments-container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      align-items: flex-start;
    }

    .video-section, .comments-section {
      flex: 1;
      min-width: 300px;
    }

    .comments-section h2 {
      margin-top: 0;
    }

    @media (max-width: 768px) {
      .video-comments-container {
        flex-direction: column;
      }
      .video-section, .comments-section {
        width: 100%;
      }
    }

    footer {
      margin-top: 20px;
      text-align: center;
      font-size: 0.9em;
      color: #888;
    }

    footer a {
      color: var(--button-bg);
      text-decoration: none;
      margin: 0 5px;
    }

    footer a:hover {
      text-decoration: underline;
    }

    .policy-section {
      margin-top: 20px;
      padding: 10px;
      background: var(--instructions-bg);
      border-radius: 4px;
      font-size: 0.9em;
    }

    .policy-section h3 {
      margin-top: 0;
    }
  </style>
</head>
<body>
  <div id="settingsOverlay"></div>
  <div id="settingsPopup">
    <h2>Settings</h2>
    <label>Dark Mode: <input type="checkbox" id="darkModeToggle" checked></label>
    <label>Background Color: <input type="text" id="bgColorInput" placeholder="#1a1a1a"></label>
    <label>Button Color: <input type="text" id="btnColorInput" placeholder="#1e90ff"></label>
    <label>Text Color: <input type="text" id="textColorInput" placeholder="#e0e0e0"></label>
    <label>Comments Background: <input type="text" id="commentsBgInput" placeholder="#222"></label>
    <label>Stream List Background: <input type="text" id="streamListBgInput" placeholder="#444"></label>
    <label>Overlay Background: <input type="text" id="overlayBgInput" placeholder="rgba(0,0,0,0.7)"></label>
    <label>Camera: <select id="cameraSelect"></select></label>
    <label>Microphone: <select id="audioSelect"></select></label>
    <p style="font-size: 0.9em; color: var(--text-color);">
      Enter colors in hex format (e.g., #RRGGBB) for all fields except Overlay Background, which can be in rgba format (e.g., rgba(0,0,0,0.5)).
    </p>
    <button onclick="applyColors()">Apply</button>
    <button onclick="resetColors()">Reset</button>
    <button onclick="closeSettings()">Close</button>
  </div>

  <div id="signalingOverlay"></div>
  <div id="signalingPopup">
    <h3>Your Signaling Data</h3>
    <p style="font-size: 0.9em; color: var(--text-color);">
      <strong>Privacy Reminder:</strong> Sharing this data will expose your IP address to the recipient. Use a VPN for added privacy.
    </p>
    <textarea id="signalingDataOutput" readonly style="height: 200px;"></textarea>
    <button onclick="copySignalingData()">Copy</button>
    <button onclick="closeSignalingPopup()">Close</button>
  </div>

  <div id="privacyOverlay"></div>
  <div id="privacyPopup">
    <h3>Welcome to BitStreams</h3>
    <p>
      BitStreams uses peer-to-peer (P2P) technology, which may expose your IP address to other users. We recommend using a VPN for privacy. By proceeding, you agree to our Terms of Service and Privacy Policy (see below).
    </p>
    <button onclick="acknowledgePrivacyPolicy()">I Agree</button>
  </div>

  <div id="container">
    <h1>BitStreams - P2P Livestreaming</h1>

    <div class="section">
      <button onclick="openSettings()">Settings</button>
      <button onclick="toggleInstructions()" id="toggleInstructionsBtn">Show Instructions</button>
    </div>

    <div class="section">
      <div id="instructions">
        <strong>Instructions:</strong><br>
        1. Broadcaster: Enter your BitStream Name, then click "Start Stream" to begin broadcasting.<br>
        2. Broadcaster: Set a Stream Title (optional) to let viewers know what your stream is about.<br>
        3. Broadcaster: Click "Generate Signaling Data", then copy the JSON data from the popup and share it with Viewer A (e.g., via chat) if not using automatic discovery.<br>
        4. Viewer: Enter your BitStream Name, select a stream from Active Streams, or paste JSON data and click "Connect" for manual connection.<br>
        5. Viewer: The app will automatically request signaling data from peers in the network, or use the manual JSON response to complete the connection.<br>
        6. Viewer: Click "Share Stream" to relay the stream to others.<br>
        7. Click "Enable 1v1 Chat" to share your video with the upstream peer (optional).<br>
        8. Double-click the video to toggle fullscreen mode.<br>
        <strong>Note:</strong> WebRTC requires HTTPS. If testing locally, use Chrome with --allow-file-access-from-files.<br>
        <strong>Privacy Notice:</strong> BitStreams uses P2P technology, meaning your IP address may be visible to other users. We strongly recommend using a VPN to protect your privacy.
      </div>
      <input type="text" id="bitStreamName" placeholder="Enter your BitStream Name">
      <div class="button-group">
        <button onclick="startStream()">Start Stream</button>
        <button onclick="stopStream()" id="stopStreamBtn" style="display: none;">Stop Stream</button>
        <button onclick="generateSignalingData()">Generate Signaling Data</button>
        <button onclick="shareStream()" id="shareStreamBtn" style="display: none;">Share Stream</button>
        <button onclick="toggleCamera()" id="cameraToggle">Enable 1v1 Chat</button>
      </div>
    </div>

    <div class="section" id="streamTitleSection">
      <input type="text" id="streamTitle" placeholder="Enter your stream title">
      <button onclick="updateStreamTitle()">Update Stream Title</button>
    </div>

    <div class="section">
      <div id="streamTitleDisplay"></div>
      <div id="peersConnected">Peers Connected: 0</div>
    </div>

    <div class="video-comments-container">
      <div class="video-section">
        <video id="localVideo" autoplay muted></video>
        <video id="remoteVideo" autoplay ondblclick="toggleFullscreen()"></video>
        <div id="volumeControl">
          <label>Volume: </label>
          <input type="range" id="volumeSlider" min="0" max="1" step="0.01" value="1" oninput="adjustVolume()">
        </div>
      </div>

      <div class="comments-section">
        <h2>Live Comments</h2>
        <div id="comments"></div>
        <input type="text" id="commentInput" placeholder="Type a comment...">
        <button onclick="sendComment()">Send</button>
      </div>
    </div>

    <div class="section">
      <h2>Active Streams</h2>
      <ul id="streamList"></ul>
    </div>

    <div class="section">
      <h2>Connect to Peer</h2>
      <textarea id="signalingData" placeholder="Paste signaling data here"></textarea>
      <button onclick="connectToPeer()">Connect</button>
    </div>

    <div class="policy-section">
      <h3>Terms of Service</h3>
      <p>By using BitStreams, you agree to use it responsibly. We are not liable for any misuse, data loss, or privacy issues arising from P2P connections. Use a VPN to protect your IP address.</p>
    </div>

    <div class="policy-section">
      <h3>Privacy Policy</h3>
      <p>BitStreams does not collect or store personal data. As a P2P app, your IP address may be visible to peers. We recommend using a VPN. No other data is shared or stored by us.</p>
    </div>

    <footer>
      Developed by BitcoinJake09 | <a href="https://github.com/BitcoinJake09/BitStream" target="_blank">GitHub Repository</a>
    </footer>
  </div>

  <script>
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const volumeControl = document.getElementById('volumeControl');
    const volumeSlider = document.getElementById('volumeSlider');
    const streamList = document.getElementById('streamList');
    const comments = document.getElementById('comments');
    const commentInput = document.getElementById('commentInput');
    const signalingData = document.getElementById('signalingData');
    const signalingDataOutput = document.getElementById('signalingDataOutput');
    const cameraSelect = document.getElementById('cameraSelect');
    const audioSelect = document.getElementById('audioSelect');
    const cameraToggle = document.getElementById('cameraToggle');
    const shareStreamBtn = document.getElementById('shareStreamBtn');
    const stopStreamBtn = document.getElementById('stopStreamBtn');
    const settingsPopup = document.getElementById('settingsPopup');
    const settingsOverlay = document.getElementById('settingsOverlay');
    const signalingPopup = document.getElementById('signalingPopup');
    const signalingOverlay = document.getElementById('signalingOverlay');
    const privacyPopup = document.getElementById('privacyPopup');
    const privacyOverlay = document.getElementById('privacyOverlay');
    const bgColorInput = document.getElementById('bgColorInput');
    const btnColorInput = document.getElementById('btnColorInput');
    const textColorInput = document.getElementById('textColorInput');
    const commentsBgInput = document.getElementById('commentsBgInput');
    const streamListBgInput = document.getElementById('streamListBgInput');
    const overlayBgInput = document.getElementById('overlayBgInput');
    const darkModeToggle = document.getElementById('darkModeToggle');
    const instructions = document.getElementById('instructions');
    const toggleInstructionsBtn = document.getElementById('toggleInstructionsBtn');
    const bitStreamNameInput = document.getElementById('bitStreamName');
    const streamTitleSection = document.getElementById('streamTitleSection');
    const streamTitleInput = document.getElementById('streamTitle');
    const streamTitleDisplay = document.getElementById('streamTitleDisplay');
    const peersConnectedDisplay = document.getElementById('peersConnected');
    let localStream = null;
    let receivedStreams = new Map();
    let activeStream = null;
    let streamId = Math.random().toString(36).substring(2, 10);
    let bitStreamName = '';
    let streamTitle = '';
    let selectedCamera = null;
    let selectedAudio = null;
    let isBroadcaster = false;
    let upstreamPeerIds = new Set();
    let peersConnected = 0;
    let viewCount = 0;
    const peers = new Map();
    const knownStreams = new Map();
    const commentQueue = new Map();
    const networkMap = new Map();
    const knownPeers = new Set();
    let propagationIntervalId = null;

    const iceServers = [
      { urls: 'stun:stun.l.google.com:19302' },
      { urls: 'stun:stun1.l.google.com:19302' },
      { urls: 'stun:stun2.l.google.com:19302' },
      { urls: 'stun:stun3.l.google.com:19302' },
      { urls: 'stun:stun4.l.google.com:19302' },
      { urls: 'stun:global.stun.twilio.com:3478' },
      { urls: 'stun:stun.nextcloud.com:443' },
      { urls: 'stun:stun.stunprotocol.org:3478' }
    ];

    let isDarkMode = localStorage.getItem('darkMode') !== 'false';

    function applyTheme() {
      const root = document.documentElement;
      if (isDarkMode) {
        root.classList.add('dark-mode');
        root.classList.remove('light-mode');
      } else {
        root.classList.add('light-mode');
        root.classList.remove('dark-mode');
      }
      localStorage.setItem('darkMode', isDarkMode);

      root.style.setProperty('--background', isDarkMode ? '#1a1a1a' : '#f0f0f0');
      root.style.setProperty('--container-bg', isDarkMode ? '#2a2a2a' : 'white');
      root.style.setProperty('--text-color', isDarkMode ? '#e0e0e0' : '#333');
      root.style.setProperty('--button-bg', isDarkMode ? '#1e90ff' : '#007bff');
      root.style.setProperty('--button-hover', isDarkMode ? '#1c7cd6' : '#0056b3');
      root.style.setProperty('--instructions-bg', isDarkMode ? '#333' : '#e9ecef');
      root.style.setProperty('--comments-bg', isDarkMode ? '#222' : '#fafafa');
      root.style.setProperty('--stream-list-bg', isDarkMode ? '#444' : '#eee');
      root.style.setProperty('--stream-list-hover', isDarkMode ? '#555' : '#ddd');
      root.style.setProperty('--input-bg', isDarkMode ? '#333' : 'white');
      root.style.setProperty('--input-text', isDarkMode ? '#e0e0e0' : '#333');
      root.style.setProperty('--input-border', isDarkMode ? '#555' : '#ccc');
      root.style.setProperty('--shadow', isDarkMode ? 'rgba(0,0,0,0.5)' : 'rgba(0,0,0,0.1)');
      root.style.setProperty('--overlay-bg', isDarkMode ? 'rgba(0,0,0,0.7)' : 'rgba(0,0,0,0.5)');

      bgColorInput.placeholder = isDarkMode ? '#1a1a1a' : '#f0f0f0';
      btnColorInput.placeholder = isDarkMode ? '#1e90ff' : '#007bff';
      textColorInput.placeholder = isDarkMode ? '#e0e0e0' : '#333';
      commentsBgInput.placeholder = isDarkMode ? '#222' : '#fafafa';
      streamListBgInput.placeholder = isDarkMode ? '#444' : '#eee';
      overlayBgInput.placeholder = isDarkMode ? 'rgba(0,0,0,0.7)' : 'rgba(0,0,0,0.5)';
    }

    darkModeToggle.addEventListener('change', () => {
      isDarkMode = darkModeToggle.checked;
      applyTheme();
      updateColorInputs();
    });

    function updatePropagationInterval() {
      if (propagationIntervalId) {
        clearInterval(propagationIntervalId);
      }
      const interval = 2000 + (Math.floor(knownPeers.size / 100) * 2000);
      propagationIntervalId = setInterval(() => {
        peers.forEach((peer, peerId) => {
          if (commentQueue.has(peerId) && peer.pc.connectionState === 'connected' && peer.dc && peer.dc.readyState === 'open') {
            console.log(`Periodic queue check for peerId: ${peerId}, data channel state: ${peer.dc.readyState}`);
            processQueue(peerId);
          }
        });
        propagateNetworkInfo();
      }, interval);
      console.log(`Propagation interval updated to ${interval}ms for ${knownPeers.size} peers`);
    }

    async function populateDeviceLists() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(device => device.kind === 'videoinput');
        const audioDevices = devices.filter(device => device.kind === 'audioinput');

        cameraSelect.innerHTML = videoDevices.map(device =>
          `<option value="${device.deviceId}">${device.label || 'Camera'}</option>`
        ).join('');
        if (videoDevices.length > 0) {
          selectedCamera = videoDevices[0].deviceId;
        }

        audioSelect.innerHTML = audioDevices.map(device =>
          `<option value="${device.deviceId}">${device.label || 'Microphone'}</option>`
        ).join('');
        if (audioDevices.length > 0) {
          selectedAudio = audioDevices[0].deviceId;
        }
      } catch (err) {
        console.error('Error enumerating devices:', err);
        alert('Unable to list devices');
      }
    }

    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        remoteVideo.requestFullscreen().catch(err => {
          console.error('Error attempting to enable fullscreen:', err);
        });
      } else {
        document.exitFullscreen();
      }
    }

    function adjustVolume() {
      remoteVideo.volume = volumeSlider.value;
    }

    function toggleInstructions() {
      if (instructions.style.display === 'none') {
        instructions.style.display = 'block';
        toggleInstructionsBtn.textContent = 'Hide Instructions';
      } else {
        instructions.style.display = 'none';
        toggleInstructionsBtn.textContent = 'Show Instructions';
      }
    }

    function openSignalingPopup() {
      signalingPopup.style.display = 'block';
      signalingOverlay.style.display = 'block';
    }

    function closeSignalingPopup() {
      signalingPopup.style.display = 'none';
      signalingOverlay.style.display = 'none';
    }

    function copySignalingData() {
      const signalingDataOutput = document.getElementById('signalingDataOutput');
      const copyButton = document.querySelector('#signalingPopup button[onclick="copySignalingData()"]');

      navigator.clipboard.writeText(signalingDataOutput.value)
        .then(() => {
          copyButton.textContent = 'Copied!';
          setTimeout(() => {
            copyButton.textContent = 'Copy';
          }, 2000);
        })
        .catch(err => {
          console.error('Failed to copy signaling data:', err);
          alert('Failed to copy. Please copy the text manually.');
        });
    }

    function showPrivacyPopup() {
      const hasAcknowledged = localStorage.getItem('privacyAcknowledged');
      if (!hasAcknowledged) {
        privacyPopup.style.display = 'block';
        privacyOverlay.style.display = 'block';
      }
    }

    function acknowledgePrivacyPolicy() {
      localStorage.setItem('privacyAcknowledged', 'true');
      privacyPopup.style.display = 'none';
      privacyOverlay.style.display = 'none';
    }

    function updateStreamTitle() {
      streamTitle = streamTitleInput.value.trim();
      if (streamTitle && isBroadcaster) {
        streamTitleDisplay.textContent = streamTitle;
        const msg = { type: 'streamTitle', title: streamTitle };
        peers.forEach((peer, peerId) => {
          if (peer.pc.connectionState === 'connected' && peer.dc && peer.dc.readyState === 'open') {
            console.log(`Sending stream title to peerId: ${peerId}`);
            peer.dc.send(JSON.stringify(msg));
          } else {
            queueMessage(peerId, msg);
          }
        });
        if (knownStreams.has(streamId)) {
          knownStreams.get(streamId).title = streamTitle;
        }
        updateStreamList();
      }
    }

    function queueMessage(peerId, message) {
      if (!commentQueue.has(peerId)) {
        commentQueue.set(peerId, []);
      }
      commentQueue.get(peerId).push(message);
      console.log(`Queued message for peerId: ${peerId}, message:`, message);
    }

    function processQueue(peerId) {
      if (commentQueue.has(peerId)) {
        const queue = commentQueue.get(peerId);
        const peer = peers.get(peerId);
        if (!peer || !peer.dc) {
          console.warn(`No peer or data channel for peerId: ${peerId}`);
          return;
        }
        console.log(`Processing queue for peerId: ${peerId}, data channel state: ${peer.dc.readyState}`);
        while (queue.length > 0 && peer.pc.connectionState === 'connected' && peer.dc.readyState === 'open') {
          const message = queue.shift();
          console.log(`Sending queued message to peerId: ${peerId}, message:`, message);
          peer.dc.send(JSON.stringify(message));
        }
        if (queue.length === 0) {
          commentQueue.delete(peerId);
        } else {
          console.log(`Remaining messages in queue for peerId: ${peerId}, queue:`, queue);
        }
      }
    }

    function updatePeerCount() {
      peersConnected = 0;
      peers.forEach((peer) => {
        if (peer.pc.connectionState === 'connected') {
          peersConnected++;
        }
      });

      if (isBroadcaster) {
        viewCount = 0;
        peers.forEach((peer, peerId) => {
          if (peer.pc.connectionState === 'connected') {
            viewCount++;
            if (peer.downstreamPeerCount !== undefined) {
              viewCount += peer.downstreamPeerCount;
            }
          }
        });
        viewCount = Math.max(0, viewCount - 1); // Subtract 1 to exclude streamer
        peersConnectedDisplay.textContent = `Viewers: ${viewCount}`;
        const msg = { type: 'totalViewers', count: viewCount };
        peers.forEach((peer, peerId) => {
          if (peer.pc.connectionState === 'connected' && peer.dc && peer.dc.readyState === 'open') {
            peer.dc.send(JSON.stringify(msg));
          } else {
            queueMessage(peerId, msg);
          }
        });
      } else {
        peersConnectedDisplay.textContent = `Peers Connected: ${peersConnected}`;
        upstreamPeerIds.forEach(peerId => {
          const peer = peers.get(peerId);
          if (peer && peer.pc.connectionState === 'connected' && peer.dc && peer.dc.readyState === 'open') {
            peer.dc.send(JSON.stringify({
              type: 'peerCount',
              count: peersConnected
            }));
          } else {
            queueMessage(peerId, { type: 'peerCount', count: peersConnected });
          }
        });
      }
    }

    async function renegotiate(peerId) {
      const peer = peers.get(peerId);
      if (!peer || peer.pc.signalingState === 'closed') return;
      try {
        const offer = await peer.pc.createOffer();
        await peer.pc.setLocalDescription(offer);
        console.log(`Renegotiation offer created for peerId: ${peerId}`);
        const signalingMsg = JSON.stringify({
          type: 'offer',
          offer: peer.pc.localDescription,
          iceCandidates: peer.iceCandidates,
          streamId,
          peerId
        });
        signalingDataOutput.value = signalingMsg;
        openSignalingPopup();
        alert(`Connection failed. New signaling data generated for peerId: ${peerId}. Please share this with the peer and try again.`);
      } catch (err) {
        console.error(`Renegotiation failed for peerId: ${peerId}, error:`, err);
      }
    }

    function createPeerConnection(peerId, isDownstream = false) {
      console.log(`${isBroadcaster ? 'Broadcaster' : 'Viewer'} creating peer connection for peerId: ${peerId}, isDownstream: ${isDownstream}`);
      const pc = new RTCPeerConnection({ iceServers });
      const iceCandidates = [];
      let dc = pc.createDataChannel('bitstreams');

      pc.onicecandidate = (event) => {
        if (event.candidate) {
          console.log(`ICE candidate collected for peerId: ${peerId}, candidate:`, event.candidate);
          iceCandidates.push(event.candidate);
        }
      };

      pc.ontrack = (event) => {
        console.log(`Received remote track from peerId: ${peerId}, event:`, event);
        const stream = event.streams[0];
        receivedStreams.set(peerId, stream);
        if (!activeStream || !activeStream.active) {
          activeStream = stream;
          remoteVideo.srcObject = activeStream;
          remoteVideo.style.display = 'block';
          volumeControl.style.display = 'block';
          shareStreamBtn.style.display = 'block';
        }

        peers.forEach((peer, pid) => {
          if (peer.isDownstream && peer.pc.signalingState !== 'closed') {
            console.log(`Forwarding received stream to downstream peerId: ${pid}`);
            stream.getTracks().forEach(track => {
              peer.pc.addTrack(track, stream);
              console.log(`Forwarded track to peerId: ${pid}, track:`, track);
            });
          }
        });
      };

      pc.onconnectionstatechange = () => {
        console.log(`Peer connection state for peerId: ${peerId}, state: ${pc.connectionState}`);
        if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected' || pc.connectionState === 'closed') {
          console.log(`Connection with peerId: ${peerId} failed or closed`);
          receivedStreams.delete(peerId);
          upstreamPeerIds.delete(peerId);
          knownPeers.delete(peerId);
          if (activeStream === receivedStreams.get(peerId)) {
            activeStream = null;
            remoteVideo.srcObject = null;
            remoteVideo.style.display = 'none';
            volumeControl.style.display = 'none';
            for (let [pid, stream] of receivedStreams) {
              if (stream.active) {
                activeStream = stream;
                remoteVideo.srcObject = activeStream;
                remoteVideo.style.display = 'block';
                volumeControl.style.display = 'block';
                break;
              }
            }
          }
          updatePeerCount();
          updatePropagationInterval();
          connectToAvailablePeers();
        } else if (pc.connectionState === 'connected') {
          console.log(`Connection successfully established with peerId: ${peerId}`);
          updatePeerCount();
          if (isBroadcaster && dc && dc.readyState === 'open') {
            console.log(`Resending streamInfo to peerId: ${peerId}`);
            dc.send(JSON.stringify({
              type: 'streamInfo',
              streamId,
              name: bitStreamName,
              bitStreamName,
              title: streamTitle || 'Untitled Stream'
            }));
            if (streamTitle) {
              console.log(`Resending streamTitle to peerId: ${peerId}`);
              dc.send(JSON.stringify({
                type: 'streamTitle',
                title: streamTitle
              }));
            }
          }
          knownStreams.forEach(s => {
            if (dc && dc.readyState === 'open') {
              console.log(`Resending known streamInfo to peerId: ${peerId}, stream:`, s);
              dc.send(JSON.stringify({
                type: 'streamInfo',
                streamId: s.id,
                name: s.name,
                bitStreamName: s.bitStreamName || 'Anonymous',
                title: s.title || 'Untitled Stream'
              }));
            }
          });
          processQueue(peerId);
          propagateNetworkInfo();
        }
      };

      pc.oniceconnectionstatechange = () => {
        console.log(`ICE connection state for peerId: ${peerId}, state: ${pc.iceConnectionState}`);
      };

      pc.onicegatheringstatechange = () => {
        console.log(`ICE gathering state for peerId: ${peerId}, state: ${pc.iceGatheringState}`);
      };

      pc.ondatachannel = (event) => {
        console.log(`Received data channel from peerId: ${peerId}`);
        dc = event.channel;
        setupDataChannel(dc, peerId);
        peers.get(peerId).dc = dc;
      };

      setupDataChannel(dc, peerId);

      if (localStream) {
        console.log(`Adding local stream tracks to peer connection for peerId: ${peerId}`);
        localStream.getTracks().forEach(track => {
          pc.addTrack(track, localStream);
          console.log(`Added local track:`, track);
        });
      }

      if (isDownstream && receivedStreams.size > 0) {
        console.log(`Forwarding received stream to downstream peerId: ${peerId}`);
        const stream = Array.from(receivedStreams.values()).find(s => s.active);
        if (stream) {
          stream.getTracks().forEach(track => {
            pc.addTrack(track, stream);
            console.log(`Forwarded track to peerId: ${peerId}, track:`, track);
          });
        }
      }

      peers.set(peerId, { pc, dc, iceCandidates, isDownstream, downstreamPeerCount: 0 });
      networkMap.set(peerId, { streamId, peerId });
      knownPeers.add(peerId);
      updatePropagationInterval();
      return pc;
    }

    function setupDataChannel(dc, peerId) {
      dc.onopen = () => {
        console.log(`Data channel opened with peerId: ${peerId}, state: ${dc.readyState}`);
        if (isBroadcaster) {
          console.log(`Sending streamInfo to peerId: ${peerId}`);
          dc.send(JSON.stringify({
            type: 'streamInfo',
            streamId,
            name: bitStreamName,
            bitStreamName,
            title: streamTitle || 'Untitled Stream'
          }));
          if (streamTitle) {
            console.log(`Sending streamTitle to peerId: ${peerId}`);
            dc.send(JSON.stringify({
              type: 'streamTitle',
              title: streamTitle
            }));
          }
        }
        knownStreams.forEach(s => {
          console.log(`Sending known streamInfo to peerId: ${peerId}, stream:`, s);
          dc.send(JSON.stringify({
            type: 'streamInfo',
            streamId: s.id,
            name: s.name,
            bitStreamName: s.bitStreamName || 'Anonymous',
            title: s.title || 'Untitled Stream'
          }));
        });
        const networkMapMsg = { type: 'networkMap', map: Array.from(networkMap.entries()) };
        if (dc.readyState === 'open') {
          dc.send(JSON.stringify(networkMapMsg));
        } else {
          queueMessage(peerId, networkMapMsg);
        }
        processQueue(peerId);
        updatePeerCount();
        propagateNetworkInfo();
        updatePropagationInterval();
      };
      dc.onmessage = (event) => {
        console.log(`Received data channel message from peerId: ${peerId}, event:`, event);
        let msg;
        try {
          msg = JSON.parse(event.data);
        } catch (err) {
          console.error(`Failed to parse data channel message from peerId: ${peerId}, error:`, err);
          return;
        }
        console.log(`Parsed message from peerId: ${peerId}, msg:`, msg);

        if (msg.type === 'streamInfo') {
          knownStreams.set(msg.streamId, {
            id: msg.streamId,
            name: msg.name,
            bitStreamName: msg.bitStreamName || 'Anonymous',
            title: msg.title || 'Untitled Stream',
            peerId: peerId
          });
          updateStreamList();
          relayMessage(peerId, msg);
        } else if (msg.type === 'streamTitle') {
          streamTitleDisplay.textContent = msg.title;
          if (knownStreams.has(streamId)) {
            knownStreams.get(streamId).title = msg.title;
          }
          updateStreamList();
          relayMessage(peerId, msg);
        } else if (msg.type === 'comment') {
          console.log(`Displaying comment from peerId: ${peerId}, comment:`, msg);
          const div = document.createElement('div');
          div.textContent = `${msg.user}: ${msg.text}`;
          comments.appendChild(div);
          comments.scrollTop = comments.scrollHeight;
          relayMessage(peerId, msg);
        } else if (msg.type === 'peerCount') {
          peers.get(peerId).downstreamPeerCount = msg.count;
          updatePeerCount();
          relayMessage(peerId, msg);
        } else if (msg.type === 'totalViewers') {
          relayMessage(peerId, msg);
        } else if (msg.type === 'networkMap') {
          console.log(`Received network map from peerId: ${peerId}, map:`, msg.map);
          msg.map.forEach(([pid, data]) => {
            if (pid !== peerId && !peers.has(pid)) {
              networkMap.set(pid, data);
              knownPeers.add(pid);
            }
          });
          updatePropagationInterval();
          connectToAvailablePeers();
        } else if (msg.type === 'request_offer') {
          handleOfferRequest(peerId, msg.streamId, msg.requesterId);
        } else if (msg.type === 'offer') {
          handleOffer(peerId, msg);
        } else if (msg.type === 'answer') {
          handleAnswer(peerId, msg);
        } else {
          console.warn(`Unknown message type from peerId: ${peerId}, msg:`, msg);
        }
      };
      dc.onerror = (error) => {
        console.error(`Data channel error for peerId: ${peerId}, error:`, error);
      };
      dc.onclose = () => {
        console.log(`Data channel closed for peerId: ${peerId}`);
        knownPeers.delete(peerId);
        updatePeerCount();
        updatePropagationInterval();
      };
      dc.onstatechange = () => {
        console.log(`Data channel state changed for peerId: ${peerId}, state: ${dc.readyState}`);
      };
    }

    function relayMessage(senderPeerId, msg) {
      console.log(`Relaying message from senderPeerId: ${senderPeerId}, msg:`, msg);
      peers.forEach((peer, peerId) => {
        if (peerId !== senderPeerId) {
          if (peer.pc.connectionState === 'connected' && peer.dc && peer.dc.readyState === 'open') {
            console.log(`Relaying message to peerId: ${peerId}, msg:`, msg);
            peer.dc.send(JSON.stringify(msg));
          } else {
            console.log(`Data channel not open for peerId: ${peerId}, state: ${peer.dc ? peer.dc.readyState : 'no data channel'}`);
            queueMessage(peerId, msg);
          }
        } else {
          console.log(`Skipping relay to sender peerId: ${peerId}`);
        }
      });
    }

    async function startStream() {
      bitStreamName = bitStreamNameInput.value.trim();
      if (!bitStreamName) {
        alert('Please enter your BitStream Name');
        return;
      }
      alert('Privacy Reminder: Broadcasting will expose your IP address to viewers. Use a VPN for added privacy.');
      streamId = Math.random().toString(36).substring(2, 10);
      streamTitleSection.style.display = 'block';
      stopStreamBtn.style.display = 'inline-block';
      try {
        selectedCamera = cameraSelect.value;
        selectedAudio = audioSelect.value;
        localStream = await navigator.mediaDevices.getUserMedia({
          video: { deviceId: selectedCamera ? { exact: selectedCamera } : undefined },
          audio: { deviceId: selectedAudio ? { exact: selectedAudio } : undefined }
        });
        localVideo.srcObject = localStream;
        localVideo.style.display = 'block';
        isBroadcaster = true;
        cameraToggle.style.display = 'block';
        shareStreamBtn.style.display = 'none';
        knownStreams.set(streamId, { id: streamId, name: bitStreamName, bitStreamName, title: streamTitle || 'Untitled Stream', peerId: streamId });
        updateStreamList();

        peers.forEach((peer, peerId) => {
          if (peer.pc.signalingState !== 'closed') {
            console.log(`Adding local stream tracks to existing peer connection for peerId: ${peerId}`);
            localStream.getTracks().forEach(track => {
              peer.pc.addTrack(track, localStream);
              console.log(`Added local track to peerId: ${peerId}, track:`, track);
            });
          }
        });
      } catch (err) {
        console.error('Error accessing media devices:', err);
        alert('Unable to access camera/microphone');
      }
    }

    function stopStream() {
      if (isBroadcaster) {
        if (localStream) {
          localStream.getTracks().forEach(track => track.stop());
          localStream = null;
        }
        receivedStreams.clear();
        activeStream = null;
        peers.forEach(({ pc }) => pc.close());
        peers.clear();
        upstreamPeerIds.clear();
        networkMap.clear();
        knownStreams.clear();
        knownPeers.clear();
        commentQueue.clear();
        updateStreamList();
        localVideo.srcObject = null;
        localVideo.style.display = 'none';
        remoteVideo.srcObject = null;
        remoteVideo.style.display = 'none';
        volumeControl.style.display = 'none';
        streamTitleDisplay.textContent = '';
        streamTitleSection.style.display = 'none';
        signalingDataOutput.value = '';
        isBroadcaster = false;
        cameraToggle.style.display = 'block';
        shareStreamBtn.style.display = 'none';
        stopStreamBtn.style.display = 'none';
        streamId = Math.random().toString(36).substring(2, 10);
        streamTitle = '';
        peersConnected = 0;
        viewCount = 0;
        updatePeerCount();
        updatePropagationInterval();
      } else {
        peers.forEach(({ pc }, peerId) => {
          if (!upstreamPeerIds.has(peerId)) {
            pc.close();
          }
        });
        upstreamPeerIds.forEach(peerId => {
          const peer = peers.get(peerId);
          if (peer) {
            peer.pc.close();
          }
        });
        peers.clear();
        upstreamPeerIds.clear();
        receivedStreams.clear();
        activeStream = null;
        networkMap.clear();
        knownPeers.clear();
        localVideo.srcObject = null;
        localVideo.style.display = 'none';
        remoteVideo.srcObject = null;
        remoteVideo.style.display = 'none';
        volumeControl.style.display = 'none';
        streamTitleDisplay.textContent = '';
        signalingDataOutput.value = '';
        cameraToggle.style.display = 'block';
        shareStreamBtn.style.display = 'none';
        peersConnected = 0;
        updatePeerCount();
        updatePropagationInterval();
      }
    }

    async function toggleCamera() {
      if (localStream && !isBroadcaster) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
        localVideo.srcObject = null;
        localVideo.style.display = 'none';
        remoteVideo.style.display = 'block';
        cameraToggle.textContent = 'Enable 1v1 Chat';
        peers.forEach((peer, peerId) => {
          if (peer.pc.signalingState !== 'closed') {
            peer.pc.getSenders().forEach(sender => {
              peer.pc.removeTrack(sender);
              console.log(`Removed track from peerId: ${peerId}`);
            });
            const stream = Array.from(receivedStreams.values()).find(s => s.active);
            if (stream) {
              stream.getTracks().forEach(track => {
                peer.pc.addTrack(track, stream);
                console.log(`Forwarded received track to peerId: ${peerId}, track:`, track);
              });
            }
          }
        });
      } else if (!isBroadcaster) {
        bitStreamName = bitStreamNameInput.value.trim();
        if (!bitStreamName) {
          alert('Please enter your BitStream Name before enabling 1v1 chat');
          return;
        }
        try {
          selectedCamera = cameraSelect.value;
          selectedAudio = audioSelect.value;
          localStream = await navigator.mediaDevices.getUserMedia({
            video: { deviceId: selectedCamera ? { exact: selectedCamera } : undefined },
            audio: { deviceId: selectedAudio ? { exact: selectedAudio } : undefined }
          });
          localVideo.srcObject = localStream;
          localVideo.style.display = 'block';
          remoteVideo.style.display = 'block';
          cameraToggle.textContent = 'Disable 1v1 Chat';
          peers.forEach((peer, peerId) => {
            if (peer.pc.signalingState !== 'closed') {
              console.log(`Adding local stream tracks to peer connection for peerId: ${peerId}`);
              localStream.getTracks().forEach(track => {
                peer.pc.addTrack(track, localStream);
                console.log(`Added local track to peerId: ${peerId}, track:`, track);
              });
            }
          });
        } catch (err) {
          console.error('Error accessing media devices:', err);
          alert('Unable to access camera/microphone');
        }
      }
    }

    async function generateSignalingData() {
      if (!streamId || !bitStreamName) {
        alert('Please start a stream first.');
        return;
      }
      if (!localStream) {
        alert('Stream is not ready. Please wait until the stream starts.');
        return;
      }
      const peerId = Math.random().toString(36).substring(2, 10);
      const pc = createPeerConnection(peerId);
      try {
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        await new Promise(resolve => {
          if (pc.iceGatheringState === 'complete') {
            resolve();
          } else {
            const timeout = setTimeout(() => {
              console.log(`ICE gathering timeout for peerId: ${peerId}`);
              resolve();
            }, 5000);
            pc.onicegatheringstatechange = () => {
              if (pc.iceGatheringState === 'complete') {
                clearTimeout(timeout);
                resolve();
              }
            };
          }
        });
        const signalingMsg = JSON.stringify({
          type: 'offer',
          offer: pc.localDescription,
          iceCandidates: peers.get(peerId).iceCandidates,
          streamId,
          peerId,
          networkInfo: {
            peers: Array.from(knownPeers),
            streams: Array.from(knownStreams.values())
          }
        });
        console.log(`Broadcaster generated signaling data for peerId: ${peerId}, data:`, signalingMsg);
        signalingDataOutput.value = signalingMsg;
        openSignalingPopup();
      } catch (err) {
        console.error(`Error generating signaling data for peerId: ${peerId}, error:`, err);
        alert('Failed to generate signaling data. Check the console for details.');
      }
    }

    async function shareStream() {
      if (receivedStreams.size === 0) {
        alert('No stream available to share. Please connect to a stream first.');
        return;
      }
      const peerId = Math.random().toString(36).substring(2, 10);
      const pc = createPeerConnection(peerId, true);
      try {
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        await new Promise(resolve => {
          if (pc.iceGatheringState === 'complete') {
            resolve();
          } else {
            const timeout = setTimeout(() => {
              console.log(`ICE gathering timeout for peerId: ${peerId}`);
              resolve();
            }, 5000);
            pc.onicegatheringstatechange = () => {
              if (pc.iceGatheringState === 'complete') {
                clearTimeout(timeout);
                resolve();
              }
            };
          }
        });
        const signalingMsg = JSON.stringify({
          type: 'offer',
          offer: pc.localDescription,
          iceCandidates: peers.get(peerId).iceCandidates,
          streamId,
          peerId,
          networkInfo: {
            peers: Array.from(knownPeers),
            streams: Array.from(knownStreams.values())
          }
        });
        console.log(`Viewer generated signaling data for downstream peerId: ${peerId}, data:`, signalingMsg);
        signalingDataOutput.value = signalingMsg;
        openSignalingPopup();
      } catch (err) {
        console.error(`Error generating signaling data for peerId: ${peerId}, error:`, err);
        alert('Failed to generate signaling data for sharing. Check the console for details.');
      }
    }

    async function connectToPeer() {
      bitStreamName = bitStreamNameInput.value.trim();
      if (!bitStreamName) {
        alert('Please enter your BitStream Name before connecting');
        return;
      }
      alert('Privacy Reminder: Connecting to a peer will expose your IP address. Use a VPN for added privacy.');
      const data = signalingData.value.trim();
      if (!data) {
        alert('Please paste signaling data to connect to a peer.');
        return;
      }
      let msg;
      try {
        msg = JSON.parse(data);
      } catch (err) {
        console.error('JSON parsing error:', err);
        alert(`Failed to parse signaling data: ${err.message}. Ensure you copied the full JSON data.`);
        return;
      }
      if (!msg.type || !['offer', 'answer'].includes(msg.type)) {
        alert('Signaling data must have a type of "offer" or "answer".');
        return;
      }
      if (msg.type === 'offer' && (!msg.offer || !msg.streamId || !msg.peerId)) {
        alert('Offer signaling data must include "offer", "streamId", and "peerId".');
        return;
      }
      if (msg.type === 'answer' && (!msg.answer || !msg.streamId || !msg.peerId)) {
        alert('Answer signaling data must include "answer", "streamId", and "peerId".');
        return;
      }
      const peerId = msg.peerId;
      let pc = peers.get(peerId)?.pc || createPeerConnection(peerId);

      if (msg.type === 'offer') {
        upstreamPeerIds.add(peerId);
        streamId = msg.streamId;
      }

      try {
        if (msg.type === 'offer') {
          console.log(`Viewer connecting to peer with peerId: ${peerId}, offer:`, msg.offer);
          await pc.setRemoteDescription(new RTCSessionDescription(msg.offer));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          await new Promise(resolve => {
            if (pc.iceGatheringState === 'complete') {
              resolve();
            } else {
              const timeout = setTimeout(() => {
                console.log(`ICE gathering timeout for peerId: ${peerId}`);
                resolve();
              }, 5000);
              pc.onicegatheringstatechange = () => {
                if (pc.iceGatheringState === 'complete') {
                  clearTimeout(timeout);
                  resolve();
                }
              };
            }
          });
          const signalingMsg = JSON.stringify({
            type: 'answer',
            answer: pc.localDescription,
            iceCandidates: peers.get(peerId).iceCandidates,
            streamId,
            peerId
          });
          console.log(`Viewer generated answer for peerId: ${peerId}, answer:`, signalingMsg);
          signalingDataOutput.value = signalingMsg;
          openSignalingPopup();
          if (msg.networkInfo) {
            updateNetworkInfo(msg.networkInfo.peers, msg.networkInfo.streams);
            updatePropagationInterval();
          }
        } else if (msg.type === 'answer') {
          console.log(`Processing answer from peerId: ${peerId}, answer:`, msg.answer);
          await pc.setRemoteDescription(new RTCSessionDescription(msg.answer));
        }

        if (msg.iceCandidates && msg.iceCandidates.length > 0) {
          for (const candidate of msg.iceCandidates) {
            await pc.addIceCandidate(new RTCIceCandidate(candidate));
            console.log(`Added ICE candidate for peerId: ${peerId}, candidate:`, candidate);
          }
        }
        signalingData.value = '';
      } catch (err) {
        console.error(`Error during peer connection for peerId: ${peerId}, error:`, err);
        alert(`Failed to connect to peerId: ${peerId}. Check the console for details and try again with new signaling data.`);
      }
    }

    function updateNetworkInfo(newPeers, newStreams) {
      newPeers.forEach(peer => knownPeers.add(peer));
      newStreams.forEach(stream => {
        knownStreams.set(stream.id, {
          id: stream.id,
          name: stream.name,
          bitStreamName: stream.bitStreamName || 'Anonymous',
          title: stream.title || 'Untitled Stream',
          peerId: stream.peerId
        });
      });
      updateStreamList();
      updatePropagationInterval();
    }

    function propagateNetworkInfo() {
      const msg = {
        type: 'networkInfo',
        peers: Array.from(knownPeers),
        streams: Array.from(knownStreams.values())
      };
      peers.forEach((peer, peerId) => {
        if (peer.pc.connectionState === 'connected' && peer.dc && peer.dc.readyState === 'open') {
          console.log(`Propagating network info to peerId: ${peerId}, msg:`, msg);
          peer.dc.send(JSON.stringify(msg));
        } else {
          queueMessage(peerId, msg);
        }
      });
    }

    async function handleOfferRequest(peerId, targetStreamId, requesterId) {
      if (isBroadcaster && targetStreamId === streamId) {
        const newPeerId = Math.random().toString(36).substring(2, 10);
        const pc = createPeerConnection(newPeerId);
        try {
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          await new Promise(resolve => {
            if (pc.iceGatheringState === 'complete') {
              resolve();
            } else {
              const timeout = setTimeout(() => {
                console.log(`ICE gathering timeout for peerId: ${newPeerId}`);
                resolve();
              }, 5000);
              pc.onicegatheringstatechange = () => {
                if (pc.iceGatheringState === 'complete') {
                  clearTimeout(timeout);
                  resolve();
                }
              };
            }
          });
          const offerMsg = {
            type: 'offer',
            offer: pc.localDescription,
            iceCandidates: peers.get(newPeerId).iceCandidates,
            streamId,
            peerId: newPeerId,
            requesterId
          };
          console.log(`Generated offer for requesterId: ${requesterId}, peerId: ${newPeerId}`);
          const peer = peers.get(peerId);
          if (peer && peer.pc.connectionState === 'connected' && peer.dc && peer.dc.readyState === 'open') {
            peer.dc.send(JSON.stringify(offerMsg));
          } else {
            queueMessage(peerId, offerMsg);
          }
        } catch (err) {
          console.error(`Error generating offer for peerId: ${newPeerId}, error:`, err);
        }
      } else if (receivedStreams.size > 0) {
        const newPeerId = Math.random().toString(36).substring(2, 10);
        const pc = createPeerConnection(newPeerId, true);
        try {
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          await new Promise(resolve => {
            if (pc.iceGatheringState === 'complete') {
              resolve();
            } else {
              const timeout = setTimeout(() => {
                console.log(`ICE gathering timeout for peerId: ${newPeerId}`);
                resolve();
              }, 5000);
              pc.onicegatheringstatechange = () => {
                if (pc.iceGatheringState === 'complete') {
                  clearTimeout(timeout);
                  resolve();
                }
              };
            }
          });
          const offerMsg = {
            type: 'offer',
            offer: pc.localDescription,
            iceCandidates: peers.get(newPeerId).iceCandidates,
            streamId: targetStreamId,
            peerId: newPeerId,
            requesterId
          };
          console.log(`Generated relay offer for requesterId: ${requesterId}, peerId: ${newPeerId}`);
          const peer = peers.get(peerId);
          if (peer && peer.pc.connectionState === 'connected' && peer.dc && peer.dc.readyState === 'open') {
            peer.dc.send(JSON.stringify(offerMsg));
          } else {
            queueMessage(peerId, offerMsg);
          }
        } catch (err) {
          console.error(`Error generating relay offer for peerId: ${newPeerId}, error:`, err);
        }
      }
    }

    async function handleOffer(peerId, msg) {
      if (msg.requesterId !== streamId) return;
      const newPeerId = msg.peerId;
      const pc = createPeerConnection(newPeerId);
      try {
        await pc.setRemoteDescription(new RTCSessionDescription(msg.offer));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        await new Promise(resolve => {
          if (pc.iceGatheringState === 'complete') {
            resolve();
          } else {
            const timeout = setTimeout(() => {
              console.log(`ICE gathering timeout for peerId: ${newPeerId}`);
              resolve();
            }, 5000);
            pc.onicegatheringstatechange = () => {
              if (pc.iceGatheringState === 'complete') {
                clearTimeout(timeout);
                resolve();
              }
            };
          }
        });
        const answerMsg = {
          type: 'answer',
          answer: pc.localDescription,
          iceCandidates: peers.get(newPeerId).iceCandidates,
          streamId: msg.streamId,
          peerId: newPeerId
        };
        console.log(`Generated answer for peerId: ${newPeerId}`);
        const peer = peers.get(peerId);
        if (peer && peer.pc.connectionState === 'connected' && peer.dc && peer.dc.readyState === 'open') {
          peer.dc.send(JSON.stringify(answerMsg));
        } else {
          queueMessage(peerId, answerMsg);
        }
        if (msg.iceCandidates && msg.iceCandidates.length > 0) {
          for (const candidate of msg.iceCandidates) {
            await pc.addIceCandidate(new RTCIceCandidate(candidate));
            console.log(`Added ICE candidate for peerId: ${newPeerId}, candidate:`, candidate);
          }
        }
        upstreamPeerIds.add(newPeerId);
        streamId = msg.streamId;
      } catch (err) {
        console.error(`Error handling offer for peerId: ${newPeerId}, error:`, err);
      }
    }

    async function handleAnswer(peerId, msg) {
      const targetPeerId = msg.peerId;
      const peer = peers.get(targetPeerId);
      if (!peer) return;
      try {
        await peer.pc.setRemoteDescription(new RTCSessionDescription(msg.answer));
        if (msg.iceCandidates && msg.iceCandidates.length > 0) {
          for (const candidate of msg.iceCandidates) {
            await peer.pc.addIceCandidate(new RTCIceCandidate(candidate));
            console.log(`Added ICE candidate for peerId: ${targetPeerId}, candidate:`, candidate);
          }
        }
      } catch (err) {
        console.error(`Error handling answer for peerId: ${targetPeerId}, error:`, err);
      }
    }

    async function connectToAvailablePeers() {
      if (isBroadcaster) return;
      const availablePeers = Array.from(knownPeers).filter(pid => !peers.has(pid));
      for (let peerId of availablePeers.slice(0, 2)) {
        if (upstreamPeerIds.size >= 2) break;
        console.log(`Attempting to connect to additional peer: ${peerId}`);
        const pc = createPeerConnection(peerId);
        try {
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          await new Promise(resolve => {
            if (pc.iceGatheringState === 'complete') {
              resolve();
            } else {
              const timeout = setTimeout(() => {
                console.log(`ICE gathering timeout for peerId: ${peerId}`);
                resolve();
              }, 5000);
              pc.onicegatheringstatechange = () => {
                if (pc.iceGatheringState === 'complete') {
                  clearTimeout(timeout);
                  resolve();
                }
              };
            }
          });
          const signalingMsg = JSON.stringify({
            type: 'offer',
            offer: pc.localDescription,
            iceCandidates: peers.get(peerId).iceCandidates,
            streamId,
            peerId,
            requesterId: streamId
          });
          console.log(`Generated offer for additional peerId: ${peerId}, data:`, signalingMsg);
          const peer = peers.get(peerId);
          if (peer && peer.pc.connectionState === 'connected' && peer.dc && peer.dc.readyState === 'open') {
            peer.dc.send(JSON.stringify(signalingMsg));
          } else {
            queueMessage(peerId, signalingMsg);
          }
          upstreamPeerIds.add(peerId);
        } catch (err) {
          console.error(`Error connecting to additional peerId: ${peerId}, error:`, err);
        }
      }
    }

    async function watchStream(targetId) {
      if (targetId === streamId) return;
      bitStreamName = bitStreamNameInput.value.trim();
      if (!bitStreamName) {
        alert('Please enter your BitStream Name before connecting');
        return;
      }
      const stream = knownStreams.get(targetId);
      if (!stream || !stream.peerId) {
        alert('No peer available for this stream. Try manual connection.');
        return;
      }
      const peerId = stream.peerId;
      const requesterId = Math.random().toString(36).substring(2, 10);
      const msg = {
        type: 'request_offer',
        streamId: targetId,
        requesterId
      };
      const peer = peers.get(peerId);
      if (peer && peer.pc.connectionState === 'connected' && peer.dc && peer.dc.readyState === 'open') {
        console.log(`Requesting offer for streamId: ${targetId} from peerId: ${peerId}`);
        peer.dc.send(JSON.stringify(msg));
      } else {
        queueMessage(peerId, msg);
        console.log(`PeerId: ${peerId} not connected, queued offer request`);
        alert('Peer not connected. Request queued. Try manual connection if it fails.');
      }
    }

    function sendComment() {
      const text = commentInput.value.trim();
      bitStreamName = bitStreamNameInput.value.trim();
      if (!bitStreamName) {
        alert('Please enter your BitStream Name before commenting');
        return;
      }
      if (text) {
        const user = bitStreamName;
        const msg = { type: 'comment', user, text };
        const div = document.createElement('div');
        div.textContent = `${user}: ${msg.text}`;
        comments.appendChild(div);
        comments.scrollTop = comments.scrollHeight;
        peers.forEach((peer, peerId) => {
          if (peer.pc.connectionState === 'connected' && peer.dc && peer.dc.readyState === 'open') {
            console.log(`Sending comment to peerId: ${peerId}, msg:`, msg);
            peer.dc.send(JSON.stringify(msg));
          } else {
            console.log(`Data channel not open for peerId: ${peerId}, state: ${peer.dc ? peer.dc.readyState : 'no data channel'}`);
            queueMessage(peerId, msg);
          }
        });
        commentInput.value = '';
      }
    }

    function updateStreamList() {
      streamList.innerHTML = '';
      knownStreams.forEach(s => {
        const li = document.createElement('li');
        li.textContent = `${s.title} by ${s.bitStreamName}`;
        li.onclick = () => watchStream(s.id);
        streamList.appendChild(li);
      });
    }

    function rgbToHex(rgb) {
      const match = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
      if (!match) return rgb;
      const r = parseInt(match[1]).toString(16).padStart(2, '0');
      const g = parseInt(match[2]).toString(16).padStart(2, '0');
      const b = parseInt(match[3]).toString(16).padStart(2, '0');
      return `#${r}${g}${b}`;
    }

    function extractColorFromBackground(background) {
      const hexMatch = background.match(/#([0-9A-F]{3}|[0-9A-F]{6})\b/i);
      if (hexMatch) {
        return hexMatch[0];
      }
      const rgbaMatch = background.match(/rgba?\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*(,\s*\d*\.?\d+\s*)?\)/i);
      if (rgbaMatch) {
        return rgbaMatch[0];
      }
      console.warn(`Could not extract color from background: ${background}`);
      return background.split(' ')[0];
    }

    function openSettings() {
      settingsPopup.style.display = 'block';
      settingsOverlay.style.display = 'block';

      const bodyStyle = getComputedStyle(document.body);
      const button = document.querySelector('button');
      const buttonStyle = getComputedStyle(button);
      const commentsStyle = getComputedStyle(document.getElementById('comments'));
      const streamListStyle = getComputedStyle(document.getElementById('streamList'));
      const overlayStyle = getComputedStyle(document.getElementById('settingsOverlay'));

      bgColorInput.value = rgbToHex(bodyStyle.backgroundColor);
      btnColorInput.value = rgbToHex(buttonStyle.backgroundColor);
      textColorInput.value = rgbToHex(bodyStyle.color);
      commentsBgInput.value = rgbToHex(commentsStyle.backgroundColor);
      streamListBgInput.value = rgbToHex(streamListStyle.backgroundColor);
      const overlayBackground = overlayStyle.background;
      overlayBgInput.value = extractColorFromBackground(overlayBackground);

      darkModeToggle.checked = isDarkMode;
    }

    function closeSettings() {
      settingsPopup.style.display = 'none';
      settingsOverlay.style.display = 'none';
    }

    function updateColorInputs() {
      const bodyStyle = getComputedStyle(document.body);
      const button = document.querySelector('button');
      const buttonStyle = getComputedStyle(button);
      const commentsStyle = getComputedStyle(document.getElementById('comments'));
      const streamListStyle = getComputedStyle(document.getElementById('streamList'));
      const overlayStyle = getComputedStyle(document.getElementById('settingsOverlay'));

      bgColorInput.value = rgbToHex(bodyStyle.backgroundColor);
      textColorInput.value = rgbToHex(bodyStyle.color);
      btnColorInput.value = rgbToHex(buttonStyle.backgroundColor);
      commentsBgInput.value = rgbToHex(commentsStyle.backgroundColor);
      streamListBgInput.value = rgbToHex(streamListStyle.backgroundColor);
      overlayBgInput.value = extractColorFromBackground(overlayStyle.background);
    }

    function convertToHex(color) {
      const tempElement = document.createElement('div');
      tempElement.style.color = color;
      document.body.appendChild(tempElement);
      const computedColor = getComputedStyle(tempElement).color;
      document.body.removeChild(tempElement);

      let match = computedColor.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
      if (match) {
        const r = parseInt(match[1]).toString(16).padStart(2, '0');
        const g = parseInt(match[2]).toString(16).padStart(2, '0');
        const b = parseInt(match[3]).toString(16).padStart(2, '0');
        return `#${r}${g}${b}`;
      }

      match = computedColor.match(/^rgba\((\d+),\s*(\d+),\s*(\d+),\s*[\d.]+\)$/);
      if (match) {
        const r = parseInt(match[1]).toString(16).padStart(2, '0');
        const g = parseInt(match[2]).toString(16).padStart(2, '0');
        const b = parseInt(match[3]).toString(16).padStart(2, '0');
        return `#${r}${g}${b}`;
      }

      if (/^#([0-9A-F]{3}){1,2}$/i.test(color)) {
        return color;
      }

      console.warn(`Could not convert color to hex: ${color}, computed: ${computedColor}`);
      return color;
    }

    function isValidColor(color) {
      const s = new Option().style;
      s.color = color;
      return s.color !== '';
    }

    function isValidHexColor(color) {
      return /^#([0-9A-F]{3}){1,2}$/i.test(color);
    }

    function applyColors() {
      const root = document.documentElement;
      const bgColor = bgColorInput.value.trim();
      const btnColor = btnColorInput.value.trim();
      const textColor = textColorInput.value.trim();
      const commentsBgColor = commentsBgInput.value.trim();
      const streamListBgColor = streamListBgInput.value.trim();
      const overlayBgColor = overlayBgInput.value.trim();
      let hasError = false;

      isDarkMode = darkModeToggle.checked;
      localStorage.setItem('darkMode', isDarkMode);

      if (bgColor && isValidColor(bgColor)) {
        root.style.setProperty('--background', bgColor);
        root.style.setProperty('--container-bg', bgColor);
        root.style.setProperty('--instructions-bg', bgColor);
        root.style.setProperty('--input-bg', bgColor);
      } else if (bgColor) {
        alert('Invalid Background color. Use hex (e.g., #1a1a1a).');
        hasError = true;
      }

      if (btnColor && isValidColor(btnColor)) {
        root.style.setProperty('--button-bg', btnColor);
        const hexBtnColor = isValidHexColor(btnColor) ? btnColor : convertToHex(btnColor);
        if (isValidHexColor(hexBtnColor)) {
          root.style.setProperty('--button-hover', adjustBrightness(hexBtnColor, -20));
        } else {
          alert('Button color must be convertible to hex format (e.g., #1e90ff or rgb(30,144,255)) for hover effect.');
          hasError = true;
        }
      } else if (btnColor) {
        alert('Invalid Button color. Use hex (e.g., #1e90ff).');
        hasError = true;
      }

      if (textColor && isValidColor(textColor)) {
        root.style.setProperty('--text-color', textColor);
        root.style.setProperty('--input-text', textColor);
      } else if (textColor) {
        alert('Invalid Text color. Use hex (e.g., #e0e0e0).');
        hasError = true;
      }

      if (commentsBgColor && isValidColor(commentsBgColor)) {
        root.style.setProperty('--comments-bg', commentsBgColor);
      } else if (commentsBgColor) {
        alert('Invalid Comments Background color. Use hex (e.g., #222).');
        hasError = true;
      }

      if (streamListBgColor && isValidColor(streamListBgColor)) {
        root.style.setProperty('--stream-list-bg', streamListBgColor);
        const hexStreamListColor = isValidHexColor(streamListBgColor) ? streamListBgColor : convertToHex(streamListBgColor);
        if (isValidHexColor(hexStreamListColor)) {
          root.style.setProperty('--stream-list-hover', adjustBrightness(hexStreamListColor, 10));
        } else {
          alert('Stream List Background color must be convertible to hex format (e.g., #444) for hover effect.');
          hasError = true;
        }
      } else if (streamListBgColor) {
        alert('Invalid Stream List Background color. Use  Use hex (e.g., #444).');
        hasError = true;
      }

      if (overlayBgColor && (isValidColor(overlayBgColor) || /^rgba?\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*(,\s*\d*\.?\d+\s*)?\)$/i.test(overlayBgColor))) {
        root.style.setProperty('--overlay-bg', overlayBgColor);
      } else if (overlayBgColor) {
        alert('Invalid Overlay Background color. Use rgba (e.g., rgba(0,0,0,0.7)) or hex.');
        hasError = true;
      }

      if (!hasError) {
        alert('Colors applied successfully!');
      }
    }

    function adjustBrightness(hex, percent) {
      hex = hex.replace(/^#/, '');
      if (hex.length === 3) {
        hex = hex.replace(/(.)/g, '$1$1');
      }
      let r = parseInt(hex.substring(0, 2), 16);
      let g = parseInt(hex.substring(2, 4), 16);
      let b = parseInt(hex.substring(4, 6), 16);

      r = Math.min(255, Math.max(0, Math.round(r + (r * percent / 100))));
      g = Math.min(255, Math.max(0, Math.round(g + (g * percent / 100))));
      b = Math.min(255, Math.max(0, Math.round(b + (b * percent / 100))));

      return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }

    function resetColors() {
      const root = document.documentElement;
      applyTheme();
      updateColorInputs();
      alert('Colors reset to default.');
    }

    document.addEventListener('DOMContentLoaded', async () => {
      applyTheme();
      await populateDeviceLists();
      showPrivacyPopup();
      updatePropagationInterval();
    });

  </script>
</body>
</html>
